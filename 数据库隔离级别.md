## 数据库隔离级别

### 1 事务

事务只是一个改变，是一些操作的集合。用专业的术语讲，它就是一个程序的执行单元；事物本身其实并不包含ACID四个特性，我们需要通过某些手段，尽可能地让执行单元满足这四个特性，那么，我们就可以称它为一个事务，或者说是一个正确的事务，完美的事务。



### 2 ACID 特性

+ 原子性：满足原子操作单元，对数据的操作，要么全部执行，要么全部失败。
+ 一致性：事务开始和完成，数据都必须保持一致。
+ 隔离性：事务之间是相互独立的，中间状态对外不可见。
+ 持久性：数据的修改时永久的。



### 3 隔离级别

#### 3.1 并发情况下事务引发的问题

> 一般情况下，多个单元操作并发执行，会出现这么几个问题

+ 更新丢失：最后的更新覆盖了由其他事务所做的更新

+ 脏读：A事务修改的数据还未提交，B事务就读到了A事务的结果。（破坏了隔离性）
+ 不可重复读：A事务在本次事务中，对自己未操作过的数据进行了多次读取，结果出现了不一致或记录不存在的情况。（破坏了一致性，update和delete引发）
+ 幻读：A事务在本次事务中，对自己未操作过的数据进行了多次读取，第一次读取时记录不存在，第二次读取时记录出现了。（破坏了一致性，insert引发）

#### 3.2 解决（指定标准）

为了权衡**隔离**和**并发**的矛盾，ISO定义了四个事务的隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同。

+ 未提交读（read-uncommitted）：最低级别，只能保证持久性,无法避免并发问题
+ 已提交读（read-committed）：语句级别，可避免脏读
+ 可重复读（repeatable-read）：事务级别，<span style="color:red">MySQL的默认隔离级别</span>，可避免脏读和幻读
+ 串行化（serializable）：最高级别，事务与事务完全串行化执行，毫无并发可言，性能极低。但是不会发生并发问题。

#### 3.3 实现（InnoDB）

+ 锁机制：阻止其他事务对数据进行操作，各个隔离级别主要体现在读取数据时加的锁和释放时机。
  - RU：事务读取时，不加锁
  - RC：事务读取时，加行级共享锁（读到才加锁），一旦读完，立刻释放（并不是事务结束）
  - RR：事务读取时，加行级共享锁，直到事务结束才释放。
  - SE：事务读取时，加表级共享锁，直到事务结束才释放。
+ MVCC机制：生成一个数据快照，并用这个快照来提供一定级别的一致性的读取，也成为多版本数据控制。
  - 实际就是**CAS版本控制**和**读写分离**的思想。
  - 主要用于RC和RR级别

### 4 总结图

![image-20200412141911300](C:\Users\30669\AppData\Roaming\Typora\typora-user-images\image-20200412141911300.png)