# JVM 小总结

## 1、JVM在哪里

jvm在整个jdk中处于最底层,负责于操作系统的交互,用来屏蔽操作系统环境,提供一个完整的java运行环境。

## 2、JVM的体系结构

![jvm体系结构](E:\myyyyyyyyyyyyyynote\JVM\jvm体系结构.PNG)

所谓jvm调优，大部分都在优化方法区和堆区，主要还是堆区。



## 3、类加载器

作用：加载class文件

![类加载过程](E:\myyyyyyyyyyyyyynote\JVM\类加载过程.PNG)



### 双亲委派机制

![加载器](E:\myyyyyyyyyyyyyynote\JVM\加载器.PNG)



系统类加载器想要加载一个Simple类，那么它会委托扩展类加载器先去加载，扩展类加载器又去委托根类加载器加载，如果根类加载器能够加载Simple类，那么它就会直接自己加载，然后就返回正确的加载结果。若不能，那么就会返回扩展类加载器看能否加载，以此类推。 如果大家都不能加载，那么就抛出加载异常。

![双亲委托](E:\myyyyyyyyyyyyyynote\JVM\双亲委托.PNG)



**优点：**能够提高软件系统的安全性。因为在此机制下，用户自定义的加载器不可能加载应该由父加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父加载器加载的可靠代码。例如，Java.lang.Object类总是由根类加载器加载，其他任何用户自定义的类加载器都不可能加载含有恶意代码的Java.lang.Object类。



### 沙箱安全机制

java安全模型的核心就是java沙箱。什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将java代码限定在JVM特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施保证对代码的有效隔离，防止对本地系统造成破坏。

沙箱主要限制系统资源访问，系统资源包括：CPU、内存、文件系统、网络。 不同级别的沙箱对这些资源访问的限制也可以不一样。



在java中，程序代码分为**本地代码** 和 **远程代码**，本地代码就相当于是jdk自带的本地方法，远程代码相当于是用户自己编写的代码。 本地代码默认是可信任的，远程代码则被看作是不受信任的。对于可信任的代码，可以访问一切本地资源。



## 4、Native

native关键字：凡是用native关键字修饰的方法，java已经无法调用，需要调用底层C语言实现的方法库。



**本地方法，会进入JVM中的本地方法栈，再去调用 JNI 本地方法接口，通过接口实现本地方法库中的方法。**

JNI的作用就是扩展Java的使用，融合不同的变成语言为Java所用。



## 5、运行时数据区各分区简介

### 本地方法栈

用于登记本地native方法，在执行引擎执行的时候加载本地方法库方法，通过 JNI 来调用本地方法。

### 程序计数器

每个线程都有一个程序计数器，是线程私有的，其实就是一个指针，指向方法区中的方法字节码（用来存储指向一条指令的地址，也就是将要执行的指令代码）。

### 方法区（元空间）

方法区是被所有线程共享的，包括所有字段和方法字节码，以及一些特殊方法，如构造函数、接口。

**静态变量、常量、类信息（构造方法、接口定义）、运行时常量池都存在于方法区中，但是 实例变量存在堆内存中，与方法区无关**



>  jdk1.7之前，字符串常量池放在方法区中，1.8之后字符串常量池移动到堆区。
>
> 物理上，方法区存在于本地内存中。逻辑上方法区存在于堆内存中（永久代/元空间），实际上并不存在。





在《深入理解Java虚拟机》书中是这样说的：在JDK 6的 时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta- space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。



### Java栈

在这个栈内存中，每个方法在执行的时候都会创建一个栈帧，用于存储**局部变量表、操作数栈、动态链接、和方法返回地址**等信息。



局部变量表存储的是基本数据类型、返回地址类型和对象引用。局部变量表的大小在编译期间完成分配，因此程序执行期间局部变量表的大小不会改变。

操作数栈主要用来存储运算结果及运算的操作数。在数据结构中，栈最典型的一个应用就是用来对表达式求值。程序中的所有计算过程都是借助操作数栈完成的。

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的**引用**，持有这个引用是为了支持方法调用中的动态链接就是将常量池中的符号引用在运行期间转化为直接引用。



### 堆

java堆是所有线程共享的一块内存，在虚拟机启动是创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收。从内存回收的角度看，由于现在收集器基本都是采用分代收集算法，所以java堆中还可以细分为：新生代、老年代和永久代；新生代又分为Eden空间、From Survivor空间、To Survivor空间三部分。

jdk1.8移除了永久代，改为了元空间。

![java堆划分](E:\myyyyyyyyyyyyyynote\JVM\java堆划分.PNG)



GC垃圾回收，主要是在Eden区和老年代。

堆内存不足，OOM（Out of Memory）错误

#### 新生代

+ 类诞生和成长的地方，甚至死亡。
+ Eden区：所有的对象都是在该区实例化出来的。当Eden区空间已满，会触发一次轻GC，回收掉一些垃圾对象。并将还活着的对象移到Survivor区。Eden清空。
+ Survivor区：保存没有被轻GC回收的实例成员，从Eden进入S区

#### 老年代

保存从新生代中存活下来的实例对象。



#### 永久代（元空间）

这个区域常驻内存，用来存放JDK自身携带的Class对象。也存储Java运行时的一些环境或类信息。

这个区域不存在垃圾回收。关闭VM虚拟机就会释放这个区域的内存。

如果一个启动类，加载了大量的第三方jar包，或Tomcat部署了大量应用，或大量动态生成的反射类，不断地被加载，就有可能出现OOM。



出现OOM错误，如何排查？

1、最好的肯定是能直接看到出错的代码在哪里：使用内存快照分析工具，MAT、Jprofiler

2、Debug，一行一行



MAT、Jprofiler作用：

+ 分析Dump内存文件，快速定位内存泄漏
+ 获得堆中数据
+ 获得大的对象
+ ......



#### Jprofiler 使用

1、编写测试类

```java
public class vertify{
    static byte[] bytes = new byte[1024 * 1024];
    public static void main(String[] args) {

        ArrayList<vertify> list = new ArrayList<>();
        int count = 0;
        try{
            //这里死循环，一直添加新对象，导致oom
            while(true){
                list.add(new vertify());
                count++;
            }
        }catch (OutOfMemoryError omm){
            System.out.println("count: " + count);
            omm.printStackTrace();
        }
    }

}
```

2、设置VM指令

```bash
-Xms1m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError
# -Xms 设置初始化内存分配大小
# -Xmx 设置最大分配内存
# -XX:+HeapDumpOnOutOfMemoryError 将OOM错误导出到文件中
```

3、运行结果

![OOM](E:\myyyyyyyyyyyyyynote\JVM\OOM.png)

4、用Jprofiler打开.hprof文件

![image-20200423204415438](E:\myyyyyyyyyyyyyynote\JVM\jprofiler.png)

5、然后一顿乱分析即可发现错误。。。





## 6、GC：垃圾回收

java相较于C语言的优点之一就是可以自动回收垃圾。

GC的工作区域只有在**方法区** 和**堆区**

JVM在进行GC时，并不是对以下三个区域统一回收。大部分时候，回收都是在新生代。

+ 新生代
+ 幸存区（from Survivor, to Survivor)
+ 老年代

GC有两个种类：轻GC（普通GC）， 重GC（全局GC）



常见题目

+ JVM的内存模型和分区。详细到每个区放什么。
+ 堆里面的分区有哪些？Eden，from，to，老年，说说它们的特点
+ GC的算法有哪些？标记清除法，标记整理法，复制算法，引用计数法。 怎么用？
+ 轻GC和重GC分别在什么时候发生？



![垃圾回收模型](E:\myyyyyyyyyyyyyynote\JVM\垃圾回收模型.PNG)

### 复制算法

优点：没有内存碎片

缺点：浪费了内存空间：多了一半空间永远是空to。假设Eden对象100%存活（极端情况），S区就需要很大的成本去保存活着的对象。

**复制算法最好的使用场景是对象存活率不高的情况**



### 标记清除算法

1、扫描所有对象，对活着的对象进行标记。

2、对没有标记的对象进行清除。



![image-20200423211856895](E:\myyyyyyyyyyyyyynote\JVM\标记清除.png)

优点：不需要额外的空间

缺点：两次扫描，浪费时间。 会产生内存碎片



### 标记压缩（整理）算法



![image-20200423212214407](E:\myyyyyyyyyyyyyynote\JVM\标记压缩（整理）.png)

优点：防止内存碎片产生

缺点：还是需要再扫描一次，还是浪费时间。



### 如何确定一个对象可以回收

#### 引用计数法

引用计数法就是给每个对象一个引用计数器，每当有一个地方引用它时，计数器就会加1；当引用失效时，计数器的值就会减1；任何时刻计数器的值为0的对象就是不可能再被使用的。

#### 可达性

 所谓的可达性就是通过一系列称为“GC Roots”的对象为起点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是GC Roots到这个对象不可达）时，则说明此对象是不可用的。



### 总结

时间复杂度：复制 < 标记清除 < 标记压缩

内存整齐度：复制 = 标记压缩 > 标记清除

内存利用率：标记压缩 = 标记清除 > 复制



难道没有最优算法吗？

没有最好的算法，只有最适合的算法。 分代收集算法：GC



年轻代：

+ 存活率低
+ 复制算法



老年代

+ 区域大:存活率高
+ 标记清除（内存碎片不多的情况） + 标记压缩混用

